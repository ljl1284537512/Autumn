### 数据库事务

#### 目录

- [四大特性](#事务必须满足ACID的四大特性)
- [原子性和一致性的区别](#原子性和一致性的区别)
- [事务的四种隔离级别](#事务的四种隔离级别)
- [锁的种类](#锁的种类)
- [事务具有七种传播行为](#事务具有七种传播行为)
- [Mysql引擎的区别](#Mysql引擎的区别)


####  事务必须满足ACID的四大特性

- 原子性
	一个事务内的操作是不可分割的。
- 一致性
	一个事务内的操作，要么全部成功，要么全部失败。
	A（原有500元） 转账给 B（原有0元）300元，结果要么是A有200而B有300，要么是A有500而B有0元。
- 隔离性
	两个事务之间是隔离的，互不影响。
- 持久性
	事务的执行结果是可持久化的。
	
#### 原子性和一致性的区别？

	"一个事务中A的余额和B的余额同时增长10%"这样的情况，是否保持了一致性，要看你的定义，如果我对一致性的定义是“A与B的余额总和不变”，那么一致性就被破坏，系统处于不一致和状态，而如果你对一致性的定义是“A与B增加的幅度相同”，那么一致性就没有被破坏，系统还是处于一致性的状态。或者说，数据库管理系统根本就不知道一致性是个啥东西，这都是用户通过代码来进行定义的。
	其实原子性与一致性是两个完全不同的概念，当然他们的联系也很紧密。  为了保证一致性（即10个人 的账号金额总数不变），那在我写代码的时候，如果写了代码：  A=A-5000;  那就必须要写上B=B+5000，或者是C=C+5000，这样的代码才能保证了数据库的一致性状态。  那什么是原子性？就是将上面的两行代码合成为一个事务，要么全做，要么全不做。  比如我写了两行代码：A=A+2000;  B=B+3000；如果这两行代码看成是一个事务，并且在某一时刻全执行完了，那么这个事务的原子性满足了，但却没有满足数据库的一致性。
	总结：
	1. 事务的一致性定义取决于业务（比如总额维持在5000，或者增加总金额不超过5000）；  
	2. 如果把一致性定义为总额不变，那么执行A=A+2000;B=B+3000之后，保证了原子性，但是数据库的一致性没有满足，因为这个一致性的定义是“总额不变”，而执行完语句之后，总额增加了5000；  
	3. 为什么会有“事务执行完就相当于满足了一致性”的疑问，是因为，我们把一致性定义为"总额不变"，而我们的事务中执行的语句又正好是"A=A-2000;B=B+2000"；  
	另外，依赖于数据库系统在执行事务过程中，对一些异常情况(如断电)的补偿处理（回滚），总能够保证事务中的语句要么全部执行，要么都不执行-原子性； 
	
#### 事务的四种隔离级别

##### 读未提交

- 事务A可以在事务B未提交的情况下，读取到B操作的(中间)结果。
- 引发的问题: 会引发"脏读"的问题。
- 并发性: ****
- 实现机制：1，事务对当前被读取的数据不加锁； 2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。
- 具体表现：1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。 2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。
- 注意：行级共享锁保证，当前行数据只支持其他事务读，但是不支持被其他事务修改。

##### 读已提交

- 事务A只能在事务B提交完事务之后，才能读取到B操作的结果。
- 引发的问题: 会引发"不可重复读"的问题，A在T1时读取Name值为"小明"，这个时候B操作数据库将Name值改成"小红"，A在T2时刻再次读取Name值时，该值就不是"小明"了,这就是不可重复读的问题。
- 并发性: ***
- 实现机制: 1，事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁（这个时候其他事务就有可能去修改数据）； 2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
- 具体表现：1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。 2，事务1更新某行记录时，事务2不能对这行记录做更新或者读取（防止脏读），直到事务1结束。
- 注意：行级排它锁保证，其他事务无法对其数据进行读或写。

##### 可重复读

- 解决了"不可重复读"的问题，保证A在同一个事务中多次读取某个值，都是相同的。
- 引发的问题: 会引发"幻读"的问题，比如A在查询用户U1的订单时， T1时刻查出来是1条，用户在T2时又下了一个单，A在T3的时候，再次查询用户U1的订单，发现多了一条订单。
- 并发性: **
- 实现机制: 1，事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放（防止其他事务对数据进行修改）； 2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
- 具体表现：1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。 2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。

##### 串行化

- 解决"幻读"的问题。
- 并发性: *
- 实现机制: 1，事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放； 2，事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。
- 具体表现：1，事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。 2，事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。

#### 锁的种类

##### 按照锁的粒度可分为：

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

##### 按照锁的模式可分为：
- 共享锁(S)：发生在数据查找之前，多个事务的共享锁之间可以共存；
- 排他锁(X)：发生在数据更新之前，排他锁是一个独占锁，与其他锁都不兼容；
- 更新锁(U)：发生在更新语句中，更新锁用来查找数据，当查找的数据不是要更新的数据时转化为S锁，当是要更新的数据时转化为X锁；
- 意向锁：发生在较低粒度级别的资源获取之前，表示对该资源下低粒度的资源添加对应的锁；
> 意向锁有分为：意向共享锁(IS) ，意向排他锁(IX)，意向更新锁(IU)，共享意向排他锁(SIX)，共享意向更新锁(SIU)，更新意向排他锁(UIX)

#### Mysql引擎的区别

- InnoDB（MySQL默认存储引擎 从版本5.5.5开始）
支持事务，行级锁，以及外键，拥有高并发处理能力。但是在创建索引和加载数据时，比MyISAM慢。默认的隔离级别是Repeatable Read（可重复读）

- MyISAM
不支持事务和行级锁。所以速度很快，性能优秀。可以对整张表加锁，支持并发插入，支持全文索引。

- MEMORY
支持Hash索引，内存表，Memory引擎将数据存储在内存中，表结构不是存储在内存中的，查询时不需要执行磁盘I/O操作，所以要比MyISAM和InnoDB快很多倍，但是数据库断电或是重启后，表中的数据将会丢失，表结构不会丢失。

> MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）。  
InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

#### 事务具有七种传播行为

	1、PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
	2、PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘
	3、PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
	4、PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。
	5、PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
	6、PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
	7、PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。
