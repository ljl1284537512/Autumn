# 关于volatile,重排序，内存模型，Happens-Before总结

## 引发思考的问题

1. 单线程情况下，CPU或者JVM会执行重排序优化吗？会的。
2. 单线程情况下，可以使用volatile吗？可以，但是不必要。
3. 为什么多线程情况下，需要使用volatile？
4. 内存模型是用来解决什么问题的？
5. 内存模型与Happens-Before的关系？
6. 内存屏障是如何禁用重排序的？

### 关键字

重排序，volatile，内存模型，内存屏障，Happens-Before

### Java 内存模型

> 为什么需要Java 内存模型？ Java虚拟机规范中试图定义一种模型来屏蔽掉各种硬件与操作系统的内存访问差异。以实现让Java程序在各种平台下都能达到一致的内存访问效果。

> 什么是内存模型？ Java内存模型用于规范工作内存与主内存之间数据同步操作，屏蔽各种硬件以及操作系统的内存访问差异；具备原子性，可见性，以及有序性, 并通过遵循"先行发生"原则(happens-before)来对有序性进行额外保证。

Java 内存模型的特征（Java内存模型是基于这3个特性建立的）：

- 原子性
  对于基本数据类型的访问读写是具备原子性(long和dubbo可以忽略，一般情况都不会发生某个线程只修改了“半”个变量)；对于更大范围的原子性保证，java提供了synchronized关键字来修饰，而该关键字利用monitorenter和monitorexit指令隐式的执行lock和unlock指令来保证原子性。

- 可见性
  普通变量不能保证多线程操作时变量的及时可见性，而volatile修饰的变量可以，它的特殊规则能够保证新值可以立即同步到主内存，以及每次使用前立即从主内存刷新。另外，java还提供了synchronized和final关键字。
  synchronized: 修饰的同步块，保证对一个变量执行unlock操作之前，必须先把此变量同步会主内存中（执行store,write)操作。

  > synchronized的锁为互斥锁，通过monitorenter和monitorexit来实现的。

  final: 被final修饰的变量在构造器中一旦初始化完成，并且构造器没有把"this"引用传递出去，那么在其他线程中就能看到final字段的值。 

- 有序性
  如果是本线程内观察，所有操作都是有序的(Within-Thread As-If-Serial Semantics)；如果在一个线程中观察另一个线程，所有的操作都是无序的，因为指令重排序以及工作内存与主内存同步存在延迟现象。
  synchronized: synchronized保证，一个变量在同一个时刻只允许一条线程对其进行lock操作，从侧面可以保证持有同一个锁的两个同步块只能串行进入。
  volatile: 本身包含禁止指令重排序的语义。

> synchronized可以解决原子性，可见性以及有序性.

### 主内存与工作内存

> 变量访问规则-在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

java内存模型规定了所有变量都存储在主内存中，每个线程还有自己的工作内存，工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的读写操作都必须在工作内存中进行,而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的 变量，线程间变量值的传递需要通过主内存来完成。

### 主内存与工作内存交互操作

java内存模型定义了8种操作来**规范**主内存与工作内存间变量拷贝的实现细节。并且保证以下操作都是**原子，不可再分**。

- Lock：作用于主内存的变量，它把一个变量标识未一条线程独占的状态。
- unLock: 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- Read: 作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- Load: 作用于工作内存的变量，他吧read操作从主内存中得到的变量值放入工作内存的变量副本中。
- Use: 作用于工作内存的变量, 它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- Assign: 作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- Store: 作用于工作内存的变量，它把一个工作内存中一个变量的值传送给主内存中，以便随后的write操作使用。
- Write: 作用于主内存的变量，它把Store操作从工作内存中得到的变量的值放入主内存的变量中。

### volatile修饰变量的特殊规则

volatile修饰的变量具有两种特性：

#### 1. 可见性

  可见性代表当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，例如A修改一个普通变量的值，然后向主内存进行回写，另外一个线程B在线程A回写完成之后再从主内存进行读取操作，新变量值才会对线程B可见。

> volatile修饰的变量不能保证线程安全性，因为很多看似原子操作实际上都是可分的，例如i++;

  使用volatile的基本条件有：
   (一). 运算结果并不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值；
   (二). 变量不需要与其他状态变量共同参与不变约束；

#### 1.1 可见性原理

   volatile变量赋值时，会在指令后面加入一条"lock addl $0x0, (%esp)"指令，该指令的lock前缀的作用是使得本CPU的Cache写入内存，该写入动作也会引起别的CPU或者别的内核无效化其Cache，这样其他CPU要再次读取volatile变量就需要从主存中重新获取该(最新)值。

#### 2.禁止指令重排序优化

  普通变量仅仅会保证在**该方法的执行过程中**(无线程安全问题)所有依赖赋值结果的地方都能获取正确的结果，而不能保证变量赋值操作的顺序与代码中的执行顺序一致，因为“线程内表现为串行的语义-WithinThread As-If-Serial Semantics”。单一线程执行过程中，只要保证执行的最终结果不发生异常，是允许发生指令重排序的。

> 单线程环境下，即使发生指令重排序，也不会影响到执行结果

  以如下例子阐释，并发情况下，指令重排序是如何影响执行结果的：

```java
  //共享变量
    User user = null;
    boolean inited;

    //假设A线程执行以下逻辑
    init(user);
    inited = true;


    //假设B线程执行以下逻辑
    while(!inited)
       Thread.sleep(1000);
    System.out.print(user.getName());
```

  假如A线程在执行其逻辑时，发生了指令重排序，inited=true先与init(user);执行，而对于A线程来说，最终执行的结果不会因为指令的执行顺序而受到影响。但是在并发情况下，B依赖于inited值，如果在A执行完inited=true时，CPU将执行权限交由线程B（A的时间分片用完），B的while(!true)循环正好无法成立，这个时候B去执行user.getName时，发现用户的Name其实还没来得及初始化。
  如何解决以上（并发情况下）重排序的问题？使用volatile关键字修饰inited变量。

##### 2.1 禁止指令重排序的原理

  volatile修饰的变量，赋值后多执行了一个"lock XXX"操作，这个操作相当于内存屏障，指重排序时不能把后面的指令重排序都内存屏障之前的位置。

- 内存屏障是加在哪个地方的？
  答：1.在每个volatile写操作的前面插入一个StoreStore屏障； 2.在每个volatile写操作的后面插入一个SotreLoad屏障；
- 内存屏障是如何作用的？
  答：如果在inited=true的前后分别加入内存屏障，那么inited=true就不能先执行于init(user)操作了。

### 先行发生原则(Happens-before)

- 什么是先行发生原则？
  答：那8条原则;

- 为什么要遵循先行发生原则？
  答：通过这个原则，我们可以通过几条规则一揽子地解决**并发环境下两个操作之间是否可能存在冲突的所有问题**。千万要注意，这里说的是，解决“并发环境下是否可能存在冲突的问题”，并没有说能解决并发环境下的冲突问题。

- 并发环境下两个操作之间可能存在冲突的哪些问题？
  答：以下为示例代码：

  ```java
  //以下操作在A中执行
  i = 1;
  //以下操作在B中执行
  j = i;
  //以下操作在C中执行
  i = 2;
  ```

  执行的结果j=？
  第一种情况：执行的顺序是i=1;j=i;i=2;最终j=1;
  第二种情况：执行的顺序是i=1;i=2;j=i;最终j=2;
  第三种情况：执行的顺序是i=2;i=1;j=i;最终j=1;
  线程C对变量i的影响可能会被线程B观察到，也可能不会，这个时候B线程就存在读取到过期数据的风险，不具备多线程安全性。

#### 先行发生原则-具体规则

- 程序次序规则：在一个线程内，按照代码顺序，书写在前的操作先行发生在书写在后的操作(控制流顺序按照正常流转)
- 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。
- volatile规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
- 线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作。
- 线程终止规则：线程中所有操作都先行发生于对此线程的终止检测。可以通过Thread.join方法结束，Thread.isAlive()的返回值等手段来检测线程是否已经终止。
- 线程中断规则：对线程interrupt方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted方法检测到是否有中断发生。
- 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于他的finalize()方法的开始。
- 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，则操作A先行发生于操作C。

#### 如何使用先行发生原则去判断是操作是否具备顺序性（先行发生原则的用处）

一个比较疑惑的例子：

```java
private int value=0;
public void setValue(int value){
    this.value=value;
}
public int getValue(){
    return value;
}
```

假设线程A先(时间上的先后)调用了"setValue(1)"，然后线程B调用了同一个对象的“getValue()”，那么线程B收到的返回值是多少？
先过一遍先行发生原则，看是否遵循先行发生关系：

1. 程序次序规则：不在同一个线程内执行，不符合。
2. 管程锁定规则：没有锁，不符合。
3. volatile规则：没有用volatile修饰，不符合。
4. ...
   可以发现，AB线程不符合先行发生规则中的任何一条，所以即使AB线程在操作时间上有先后顺序，但是也无法确定B中的"getValue()"方法的返回结果，这里的操作不是线程安全的。

如何解决这个问题?

- 使用volatile关键字修饰，套用volatile原则；
- 使用synchronized修饰set和get方法，套用管程锁定规则；
  只要能满足8大规则中的任意一条，就可以实现最终执行上的先行发生关系。

总结：一个操作“时间上的先发生”不代表这个操作会是“先行发生”，一个操作如果是“先行发生”的，也不能推导出其“时间上的先发生”，因为指令有重排序功能。

```java
int i = 1;
int j = 2;
```

如上代码实例，虽然在书写上i=1;先行与j=2;但是因为指令重排序，会导致j=2先行执行。
但是上面的代码是在同一个线程中执行的，那么应该符合8大规则中的第一条，那为什么不具备先行发生关系呢？
答：处理器执行发生重排序优化时，是从处理器的角度去观察的，我们在这条线程之中没有办法感知到这一点。
